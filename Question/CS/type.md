## 정적 타입 언어 vs 동적 타입 언어

### 정적 타입 언어 (Static Typed Language)

- 컴파일 시에 자료형이 결정되는 언어 (ex: C, C++, Java, ...)
- 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당 메모리 영역을 정해놓았음
- 변수에 들어갈 값의 형태에 따라 직접 변수의 타입을 명시해주어야 함

- 장점 1 : 타입 에러로 인한 문제를 컴파일 타임에 해결할 수 있다 -> 안정성이 높음
- 장점 2 : 컴파일 시에 미리 타입을 결정하기 때문에 실행속도가 빠름

- 단점 : 타입에 대한 제한으로 코드 작성시 유연함이 떨어짐

### 동적 타입 언어 (Dynamic Typed Language)

- 런타임 시에 자료형이 결정되는 언어 (ex: Python, JavaScript, ...)
- 소스코드 작성 시 명시적으로 자료형을 지정해줄 필요가 없음

- 장점 : 타입에 대한 제한이 없어 유연함, 코드 작성이 효율적임

- 단점 1 : 타입에 대한 리스크를 런타임에 감당해야 함 (사전에 버그 파악이 힘듬)
- 단점 2 : 코드가 길고 복잡해질 경우 타입 에러를 찾기가 어려워짐

### JavaScript, TypeScript에서의 비교

```jsx
const kim = { friends: ["lee", "park"] };
const friendLength = kim.friendList.length; // friends를 friendList로 잘못 입력
```

- JS의 경우 IDE가 컴파일 타임에 kim의 타입을 모르므로 에러가 나지 않음
- 어떤 객체 뒤에 .을 입력해도 해당 객체의 타입을 모르기 때문에 정보가 보이지 않음 -> 해당 객체의 모든 속성 이름을 알고 있어야하며, 기억이 안날 경우 소스 코드에서 직접 확인해야함

- TS의 경우 IDE가 kim의 타입을 알고 있기 때문에, 다음과 같은 잘못된 속성명을 입력했을 경우 에러 발생.
- 어떤 객체 뒤에 .을 입력하면 IDE가 해당 객체의 타입을 알고 있음 -> 해당 객체의 속성들의 이름을 나열해줌 ->
  생산성 향상.

### 컴파일 과정

- 소스코드를 작성하고 빌드를 하게 되면 일반적으로 다음과 같은 과정을 통해 실행파일이 만들어짐

`소스코드(Input) -> 전처리기 -> 컴파일러 -> 어셈블러 -> 링커 -> 실행파일(Output)`

- 전처리기 : 소스코드 자체에 대한 수정을 담당.
- 컴파일러 : 소스코드를 어셈블리 코드로 번역.
- 어셈블러 : 어셈블리 코드를 목적코드로 번역.
- 링커 : 생성된 목적코드들을 링킹 -> 실행파일을 만듬.

### 컴파일 타임 & 런타임

- 실행파일이 만들어지는 순간까지 -> 컴파일타임
- 실행파일이 실행된 후의 시간대 -> 런타임
